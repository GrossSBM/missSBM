---
title: "missSBM: a case study with war networks"
author: "missSBM team"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 4
bibliography: missSBMreferences.bib
link-citations: yes
vignette: >
  %\VignetteIndexEntry{missSBM: a case study with war networks}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE, 
  warning = FALSE,
  fig.width = 5, fig.height = 4)
set.seed(9876) # set seed for reproducibility
```

## Prerequesites

On top of **missSBM**, our analysis will rely on the **igraph** package for network data manipulation and **ggplot2** and **magrittr** for representation.

```{r package requirement, message=FALSE}
library(igraph)
library(ggplot2)
library(magrittr)
library(missSBM)
```

## The war network

The `war_graphs` dataset comes with the `missSBM` package:

```{r load data set}
#data("war_graphs")
load("../inst/war.Rdata")

```

This dataset contains a list of two networks (`beligerent` and `alliance`) where the nodes are countries; an edge in the network `beligerent` means that the two countries have been at war at least once between years 1816 to 2007; an edge in network `alliance` means that the two countries have had a formal alliance between years 1816 to 2012.  The network `beligerent` have less nodes since countries which have not been at war are not considered.

These two networs were extracted from [](http://www.correlatesofwar.org/) (see @sarkees2010resort for war data, and  @gibler2008international for formal alliance).

```{r war network plot, fig.height=4, fig.width=8}
par(mfrow = c(1,2))
#plot(war_graphs$alliance   , main = "Alliance")
#plot(war_graphs$beligerent , main = "Beligerent")
par(mfrow = c(1,1))
```

In the following, we focus on the network `beligerent`. We extract here the adjacency matrix of the network, a covariate on the vertices describing the military power of each country, and the country names.

```{r beligenrent network}
#beligerent_adjacency <- as_adj(war_graphs$beligerent, sparse = FALSE)
beligerent_adjacency <- as_adj(Gwar,sparse=F)
#military_power       <- get.vertex.attribute(war_graphs$beligerent)$military_power
military_power       <- get.vertex.attribute(Gwar)$mil
#countries <- get.vertex.attribute(war_graphs$beligerent)$military_power
countries <- get.vertex.attribute(Gwar)$name
trade <- Gwar.trade
```

### Generating missing data

Some data may be missing for some countries in the sense that data were collected comprehensively for a subset of countries and for the other countries we only observe their edges with the first subset and not within them. More precisely, we can assume that the sampling is node-centered and collect edges information accordingly (there will be a block of missing data on the diagonal of the adjacency matrix). To this end we rely on the function `sample` in **missSBM**:

```{r sampling node}
sampledNet_war <- missSBM::sample(beligerent_adjacency, sampling = "node", parameters = .8)
plot(sampledNet_war)
```

### Estimation with missing data

We can now adjust a Stochastic Block Model with the function `estimate` under this type of sampling:

```{r inference node, results='hide'}
vBlocks <- 1:5
collection_sbm <- missSBM::estimate(sampledNet_war, vBlocks = vBlocks, sampling = "node")
res_unsmoothed <- data.frame(
  ICL     = collection_sbm$ICL,
  nBlocks = vBlocks, 
  type    = "raw"
)
```

The `smooth` function allows the user to produce a smoothed version of the Integrated Classification Likelihood Criterion, commonly used to perform model selection. This will faciliate the choice of the number of group.

```{r smoothed node, results='hide'}
smooth(collection_sbm, "both")
res_smoothed <- data.frame(
  ICL     = collection_sbm$ICL,
  nBlocks = vBlocks, 
  type    = "smoothed"
)
```

Let us now check that the smoothing did its job correctly:

```{r smoothing effect plot}
rbind(res_unsmoothed, res_smoothed) %>% 
  ggplot(aes(x = nBlocks, y = ICL, group = type, color = type)) + 
    geom_line() + theme_bw()
```

### Estimation on fully observed network

We compare with clusterings obtained with the fully observed network.

```{r inference full, results='hide'}
collection_sbm_full <- 
  missSBM::estimate(
    sampledNet  = prepare_data(beligerent_adjacency), 
    vBlocks     = vBlocks, "node",
    clusterInit = "spectral"
  )
smooth(collection_sbm_full, "both")
```

```{r}
res_missing <- res_smoothed
res_missing$type <- "missing"
res_full <- data.frame(
  ICL     = collection_sbm_full$ICL,
  nBlocks = vBlocks, 
  type    = "full"
)
rbind(res_missing, res_full) %>% 
  ggplot(aes(x = nBlocks, y = ICL, group = type, color = type)) + 
    geom_line() + theme_bw()

```


```{r clustering comparison}
table(
  collection_sbm$bestModel$fittedSBM$memberships,
  collection_sbm_full$bestModel$fittedSBM$memberships
  )
```

```{r blockmodel comparison}
library(blockmodels)
modbm <- BM_bernoulli("SBM_sym",beligerent_adjacency,verbosity=0,plotting="")
modbm$estimate()
table(apply(modbm$memberships[[3]]$Z,1,which.max),collection_sbm_full$bestModel$fittedSBM$memberships)
modbm$model_parameters[[3]]$pi
collection_sbm_full$bestModel$fittedSBM$connectParam
collection_sbm_full$bestModel$vICL
modbm$ICL[3]*(-2)
```


COMPARAISON avec GREMLIN en plus et calculs d'ICL
```{r compare GREMLIN ICL}
library(GREMLIN)
donGR = defineNetwork(beligerent_adjacency,"adj",1,1)
resGR = multipartiteBM(list(donGR))
resGR$fittedModel[[1]]$ICL * (-2)
table(resGR$fittedModel[[1]]$paramEstim$Z[[1]])
table(resGR$fittedModel[[1]]$paramEstim$Z[[1]],apply(modbm$memberships[[3]]$Z,1,which.max))
table(resGR$fittedModel[[1]]$paramEstim$Z[[1]],collection_sbm_full$bestModel$fittedSBM$memberships)



Q=3
pimiss = collection_sbm_full$models[[Q]]$fittedSBM$connectParam
alphamiss = collection_sbm_full$models[[Q]]$fittedSBM$mixtureParam
Zmiss = collection_sbm_full$models[[Q]]$fittedSBM$blocks

pibloc = modbm$model_parameters[[Q]]$pi
alphabloc = colMeans(modbm$memberships[[Q]]$Z)
Zbloc = modbm$memberships[[Q]]$Z


piGR = resGR$fittedModel[[1]]$paramEstim$list_theta[[1]]
alphaGR = resGR$fittedModel[[1]]$paramEstim$list_pi[[1]]
ZGR = resGR$fittedModel[[1]]$paramEstim$tau[[1]]

B2 = beligerent_adjacency
class(B2)
iclalamano = function(pi,alpha,Z,adj)
{
  adj0 = 1-adj
  diag(adj0) = 0
  vA = 0
  for (i in 2:nrow(adj))
    for (j in 1:(i-1))
      for (q in 1:ncol(Z))
        for (l in 1:ncol(Z))
          vA = vA + Z[i,q]*Z[j,l]*(log(pi[q,l])*adj[i,j]+log(1-pi[q,l])*adj0[i,j])
  return(vA + sum(Z%*%log(alpha)))
}
ICLmissmano = -2*iclalamano(pimiss,alphamiss,Zmiss,B2) + log(nrow(B2)) * (ncol(Zmiss)-1) + log(nrow(B2)*(nrow(B2)-1)/2)* (ncol(Zmiss)+1)*ncol(Zmiss)/2
ICLmissmano

-2*iclalamano(pibloc,alphabloc,Zbloc,B2) + log(nrow(B2)) * (ncol(Zbloc)-1) + log(nrow(B2)*(nrow(B2)-1)/2)* (ncol(Zbloc)+1)*ncol(Zbloc)/2

-2*iclalamano(piGR,alphaGR,ZGR,B2) + log(nrow(B2)) * (ncol(Zbloc)-1) + log(nrow(B2)*(nrow(B2)-1)/2)* (ncol(Zbloc)+1)*ncol(Zbloc)/2



```


Note that `r ICLmissmano` is different from `r collection_sbm_full$bestModel$vICL`



### Taking the covariates into account

We now introduce the covariate `military_power` into the analysis. We expect a part of the network to be explained by this covariate. 

let us first prepare the data for missSBM inference on the full set of data

```{r war network with covariates}
sampleNet_cov <- prepare_data(beligerent_adjacency, list(military_power))
```

Then we run the inference on the fully observed network

```{r war network with covariates full, results = 'hide'}
collection_sbm_cov_full <- estimate(sampleNet_cov, vBlocks = 1:5, sampling = "node")
smooth(collection_sbm_cov_full)
```

We then sampled some observation according to the covariates and try to estimate the SBM with these missing entries.

```{r war network with covariates sampled, results = 'hide'}
sampleNet_cov_miss <- missSBM::sample(beligerent_adjacency, sampling = "node", parameters = missSBM:::logistic(.95), covariates = list(military_power))
collection_sbm_cov_miss <- estimate(sampleNet_cov_miss, vBlocks = 1:5, sampling = "node")
smooth(collection_sbm_cov_miss, control = list(iterate = 3))
```

```{r comparison war with covariates}
res_full <- data.frame(
  ICL     = collection_sbm_cov_full$ICL,
  nBlocks = vBlocks, 
  type    = "full"
)
res_miss <- data.frame(
  ICL     = collection_sbm_cov_miss$ICL,
  nBlocks = vBlocks, 
  type    = "miss"
)
rbind(res_miss, res_full) %>% 
  ggplot(aes(x = nBlocks, y = ICL, group = type, color = type)) + 
    geom_line() + theme_bw()
```


## References
